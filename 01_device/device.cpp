#include "device.h"

#include "../03_commands/synchronization.h"

Queue::Queue(VkQueue queue, uint32_t family_index) : m_queue(queue), m_family_index(family_index)
{}
void Queue::waitFor() const{
    //wait for all operations on the queue to finish
    vkQueueWaitIdle(m_queue);
}
Queue::operator VkQueue() const{
    return m_queue;
}
uint32_t Queue::getFamilyIndex() const{
    return m_family_index;
}
void Queue::submit(VkCommandBuffer command_buffer, const SubmitSynchronization& synchronization){
    //create submit info structure
    VkSubmitInfo submit_info = synchronization.getSubmitInfo(&command_buffer);
    //submit the buffer to the queue (1 -> 1 submit info)
    VkResult result = vkQueueSubmit(m_queue, 1, &submit_info, synchronization.getEndFence());
    DEBUG_CHECK("Command buffer submission", result);
}


Device::Device(VkDevice device, VkPhysicalDevice physical_device, const vector<VkDeviceQueueCreateInfo>& queue_infos) : 
    m_device(device), m_allocator{device, physical_device}, m_queues(queue_infos.size())
{
    //set the global allocator variable
    g_allocator.set(m_allocator);

    //max index of family to get queues from
    uint32_t family_count = 0;
    for (const VkDeviceQueueCreateInfo& queue_info : queue_infos){
        if (queue_info.queueFamilyIndex + 1 > family_count) family_count = queue_info.queueFamilyIndex + 1;
    }
    //how many queues were retrieved from each family already
    vector<uint32_t> family_index_offsets(family_count, 0); 

    //go over all queue groups to retrieve. Queue groups are specified by user and have specific properties. Queue families are generated by vulkan. Multiple groups can contain queues from the same family.
    for (uint32_t queue_group_index = 0; queue_group_index < queue_infos.size(); queue_group_index++){
        //get index of family to get queues from 
        uint32_t family_index = queue_infos[queue_group_index].queueFamilyIndex;
        //reserve space for queues
        m_queues[queue_group_index].reserve(queue_infos[queue_group_index].queueCount);
        //go through all queues to get
        for (uint32_t queue_index = 0; queue_index < queue_infos[queue_group_index].queueCount; queue_index++){
            //get queue handle and add it to the current queue group
            VkQueue queue;
            vkGetDeviceQueue(m_device, family_index, queue_index + family_index_offsets[family_index], &queue);
            m_queues[queue_group_index].emplace_back(queue, family_index);
        }
        //record the queues that were already requested from this family
        family_index_offsets[family_index] += queue_infos[queue_group_index].queueCount;
    }   
}
void Device::destroy(){
    waitFor();
    //destroy allocator and all objects created by it
    m_allocator.destroy();
    //destroy device
    vkDestroyDevice(m_device, nullptr);
}

void Device::waitFor() const{
    //wait for all operations to finish
    vkDeviceWaitIdle(m_device);
}
const VkDevice& Device::get() const{
    return m_device;
}
Device::operator VkDevice(){
    return m_device;
}
Queue& Device::getQueue(int group, int index){
    //return reference to queue from given group with given index
    return m_queues[group][index];
}